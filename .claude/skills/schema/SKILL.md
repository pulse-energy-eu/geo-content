---
name: schema
version: 2.0.0
argument-hint: "<customer-folder> [sample-article-path] e.g. hyperspell hyperspell/output/what-is-ai-agent-memory-final.md"
description: "When the user wants to generate Next.js JSON-LD integration files for a customer. Use when the user says 'schema setup,' 'generate schema templates,' 'Next.js structured data,' 'JSON-LD setup,' or 'schema.' Reads company-context and a sample article to produce page-level and layout-level TypeScript templates for the customer's Next.js project. One-time per customer, not per article."
---

# Schema — Next.js JSON-LD Integration Setup

## Arguments and Output Convention

- **`$ARGUMENTS`** = `<customer-folder> [sample-article-path]`
  - `<customer-folder>` — required (e.g. `hyperspell`)
  - `[sample-article-path]` — optional. A `-final.md` to validate frontmatter shape. If not provided, glob `{customer-folder}/output/*-final.md` and use the first match.
- **Context file**: glob `{customer-folder}/company-context-*.md` — required. Read Section 1 (company name, URL) and Section 8 (blog base URL, default author, logo URL, social profiles). If not found, tell the user to run `/company-context` first.
- **Output**: Two files in the customer root folder:
  - `{customer-folder}/page-schema.tsx` — per-page schema builder (BlogPosting + FAQPage + BreadcrumbList)
  - `{customer-folder}/layout-schema.tsx` — global schema (Organization)
- **One-time setup**: Run once per customer when onboarding. Does not need to be re-run per article.

---

You generate ready-to-use Next.js TypeScript templates that build JSON-LD structured data from blog post frontmatter. This follows the [official Next.js JSON-LD pattern](https://nextjs.org/docs/app/guides/json-ld): construct schema objects in the component and render as `<script type="application/ld+json">` with `dangerouslySetInnerHTML`.

## Pipeline Position

```
/company-context → /schema (once per customer)
Then per article: /contentwriting → /refine → /framer (optional)
```

`/schema` runs once after `/company-context` is set up. It produces integration templates that the customer adds to their Next.js project. After that, every article's frontmatter (generated by `/contentwriting` and validated by `/refine`) feeds these templates automatically.

---

## Step 1: Load Inputs

### 1.1 Read Company Context

Find and read `{customer-folder}/company-context-*.md`. Extract:

| Field | Source | Used in |
|---|---|---|
| Company name | Section 1 | Organization schema, publisher |
| Website URL | Section 1 | Organization schema, publisher |
| Blog base URL | Section 8 | Article URL, Breadcrumb |
| Default author name | Section 8 | Article author |
| Default author role | Section 8 | Article author jobTitle |
| Default author URL | Section 8 | Article author url |
| Logo URL | Section 8 | Organization logo, publisher logo |
| Social profile URLs | Section 8 | Organization sameAs |

If company-context is missing, tell the user: "Run `/company-context` first to set up the customer context."

If Section 8 is missing, warn the user and use available data from Section 1. Mark missing fields with `// TODO` comments in the output.

### 1.2 Read Sample Article (Validation)

Read the sample `-final.md` to verify the frontmatter contains the expected fields.

**Required fields**: `title`, `slug`, `author`, `date`, `tags`, `seo.metaDescription`, `wordCount`, `faqs`

If `wordCount` or `faqs` are missing, warn the user: "This article's frontmatter is missing `wordCount`/`faqs`. Articles created with `/contentwriting` v3.9.0+ include these automatically. Run `/refine` on older articles to add them."

---

## Step 2: Generate page-schema.tsx

This file contains:

1. A TypeScript interface for the blog post frontmatter
2. A function that builds three JSON-LD schemas from frontmatter (BlogPosting, FAQPage, BreadcrumbList)
3. Usage comments showing the `<script>` rendering pattern from the Next.js docs
4. XSS sanitization via `.replace(/</g, '\\u003c')`

**Use actual values from company-context** (company name, URLs, blog base URL, author info) — not abstract placeholders. The customer should be able to copy this into their project with minimal adaptation.

### Output structure

```tsx
// Blog Post JSON-LD Schemas
// Generated for {companyName} — add to your blog post page component
// e.g., app/blog/[slug]/page.tsx
//
// Follows the official Next.js JSON-LD pattern:
// https://nextjs.org/docs/app/guides/json-ld

// Frontmatter type matching the content pipeline's YAML output
interface PostFrontmatter {
  title: string
  slug: string
  author: string
  date: string
  format: string
  category: string
  tags: string[]
  seo: {
    metaTitle: string
    metaDescription: string
    primaryKeyword: string
    secondaryKeywords: string[]
    searchIntent: string
    searchVolume?: number
  }
  wordCount: number
  faqs: Array<{
    question: string
    answer: string
  }>
}

export function generateBlogSchemas(post: PostFrontmatter) {
  const blogUrl = `{blogBaseUrl}/${post.slug}`

  const articleSchema = {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    headline: post.title,
    description: post.seo.metaDescription,
    url: blogUrl,
    datePublished: post.date,
    dateModified: post.date,
    author: {
      '@type': 'Person',
      name: post.author,
      // Include url and jobTitle if available from company-context
    },
    publisher: {
      '@type': 'Organization',
      name: '{companyName}',
      url: '{websiteUrl}',
      // Include logo if available from company-context
    },
    keywords: post.tags.join(', '),
    wordCount: post.wordCount,
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': blogUrl,
    },
  }

  const faqSchema = post.faqs?.length
    ? {
        '@context': 'https://schema.org',
        '@type': 'FAQPage',
        mainEntity: post.faqs.map((faq) => ({
          '@type': 'Question',
          name: faq.question,
          acceptedAnswer: {
            '@type': 'Answer',
            text: faq.answer,
          },
        })),
      }
    : null

  const breadcrumbSchema = {
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: [
      { '@type': 'ListItem', position: 1, name: 'Home', item: '{websiteUrl}' },
      { '@type': 'ListItem', position: 2, name: 'Blog', item: '{blogBaseUrl}' },
      { '@type': 'ListItem', position: 3, name: post.title, item: blogUrl },
    ],
  }

  return { articleSchema, faqSchema, breadcrumbSchema }
}

// Usage in your page component:
//
// const { articleSchema, faqSchema, breadcrumbSchema } = generateBlogSchemas(post)
//
// return (
//   <>
//     <script
//       type="application/ld+json"
//       dangerouslySetInnerHTML={{
//         __html: JSON.stringify(articleSchema).replace(/</g, '\\u003c'),
//       }}
//     />
//     {faqSchema && (
//       <script
//         type="application/ld+json"
//         dangerouslySetInnerHTML={{
//           __html: JSON.stringify(faqSchema).replace(/</g, '\\u003c'),
//         }}
//       />
//     )}
//     <script
//       type="application/ld+json"
//       dangerouslySetInnerHTML={{
//         __html: JSON.stringify(breadcrumbSchema).replace(/</g, '\\u003c'),
//       }}
//     />
//     {/* Article content */}
//   </>
// )
```

### Replacing template values

In the code above, `{companyName}`, `{websiteUrl}`, `{blogBaseUrl}`, etc. are **instructions to you**, not literal output. Replace them with actual values from company-context when generating the file. For example, if the company is Hyperspell:

- `'{companyName}'` → `'Hyperspell'`
- `'{websiteUrl}'` → `'https://hyperspell.com'`
- `'{blogBaseUrl}'` → `'https://hyperspell.com/blog'`

### Author metadata

If company-context Section 8 provides author URL and/or role, include them in the author object:

```tsx
author: {
  '@type': 'Person',
  name: post.author,
  url: '{authorUrl}',
  jobTitle: '{authorRole}',
},
```

### Publisher logo

If company-context provides a logo URL, include it:

```tsx
publisher: {
  '@type': 'Organization',
  name: '{companyName}',
  url: '{websiteUrl}',
  logo: {
    '@type': 'ImageObject',
    url: '{logoUrl}',
  },
},
```

If no logo URL is available, omit the `logo` field entirely.

---

## Step 3: Generate layout-schema.tsx

This file contains the Organization schema — identical across all pages, placed once in the root layout.

```tsx
// Organization JSON-LD Schema
// Generated for {companyName} — add to your root layout
// e.g., app/layout.tsx
//
// This schema is global (same on every page). Add it once in your layout.

export const organizationSchema = {
  '@context': 'https://schema.org',
  '@type': 'Organization',
  name: '{companyName}',
  url: '{websiteUrl}',
  // Include logo and sameAs only if available from company-context
}

// Usage in your layout component:
//
// <script
//   type="application/ld+json"
//   dangerouslySetInnerHTML={{
//     __html: JSON.stringify(organizationSchema).replace(/</g, '\\u003c'),
//   }}
// />
```

Only include fields that have real values from company-context:
- Include `logo` only if a logo URL was found
- Include `sameAs` only if social profile URLs were found
- Never fabricate URLs

---

## Step 4: Validate & Write

### Validation

- [ ] All hardcoded URLs are absolute (start with `https://`)
- [ ] No template placeholders remain (`{blogBaseUrl}`, `{companyName}`, etc.) — all replaced with real values or marked `// TODO`
- [ ] TypeScript is syntactically valid
- [ ] The `PostFrontmatter` interface matches the current contentwriting output format
- [ ] No internal skill names, section numbers, or command references in the output files

### Write Output

Save both files to the customer root folder:
- `{customer-folder}/page-schema.tsx`
- `{customer-folder}/layout-schema.tsx`

Tell the user:
1. "Add `page-schema.tsx` to your blog post page component. It builds Article, FAQ, and Breadcrumb schemas from your markdown frontmatter."
2. "Add `layout-schema.tsx` to your root layout. It provides the Organization schema across all pages."
3. "Every article's frontmatter already contains all the data these templates need — no extra steps per post."

---

## Constraints

- **No fabrication**: Only use data from company-context. Mark missing fields with `// TODO: add {field}` rather than guessing.
- **Valid TypeScript**: Output must be syntactically valid `.tsx`.
- **Real values, not templates**: Use actual company data (URLs, names) from company-context. These files should work with minimal adaptation.
- **Customer-facing output**: Never include internal skill names (`/schema`, `/refine`, `/company-context`), internal document references ("Section 8"), or diagnostic notes. Comments in the output should help the developer integrating the code.

---

## Related Skills

- **contentwriting**: Write blog posts with complete frontmatter including `wordCount` + `faqs`
- **refine**: Polish drafts and ensure frontmatter completeness
- **company-context**: Establish brand context including Section 8 schema data (required input for this skill)
- **framer**: Format the article body for Framer CMS publishing
